<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Happy New Year 2026</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;900&family=Dancing+Script:wght@700&family=Patrick+Hand&family=Pacifico&display=swap" rel="stylesheet">
    <style>
        /* --- C·∫§U H√åNH CHUNG --- */
        body {
            margin: 0; overflow: hidden;
            background: #000;
            font-family: 'Montserrat', sans-serif;
            height: 100vh; color: white;
            user-select: none; -webkit-tap-highlight-color: transparent;
            transition: background 1.5s ease;
        }

        /* --- S√ÇN KH·∫§U PH√ÅO HOA --- */
        .stage-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden; z-index: 1;
        }
        .canvas-container {
            width: 100%; height: 100%;
            transition: filter 0.3s;
        }
        canvas {
            position: absolute; top: 0; left: 0;
            mix-blend-mode: lighten;
        }
        
        /* --- M√ÄN H√åNH B·∫ÆT ƒê·∫¶U --- */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 999;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            cursor: pointer;
        }
        .start-btn {
            padding: 20px 50px; border: 2px solid gold; color: gold;
            font-size: 1.5rem; text-transform: uppercase; letter-spacing: 2px;
            background: transparent; border-radius: 50px;
            animation: pulseBtn 1.5s infinite;
        }
        @keyframes pulseBtn { 0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(255, 215, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); } }

        /* --- UI L·ªäCH (CALENDAR) --- */
        #calendar-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 280px; height: 320px; z-index: 10;
            perspective: 1000px; display: none;
        }
        .calendar-page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; color: #333;
            border-radius: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transform-origin: top left; 
            background-image: radial-gradient(#e0e0e0 15%, transparent 16%), radial-gradient(#e0e0e0 15%, transparent 16%);
            background-size: 10px 10px; background-position: 0 0, 5px 5px;
            overflow: hidden;
            backface-visibility: hidden;
        }
        .calendar-page::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 40px;
            background: #d63031; border-radius: 10px 10px 0 0;
            border-bottom: 2px dashed rgba(255,255,255,0.5);
        }
        .cal-month { font-size: 1.5rem; margin-top: 40px; font-weight: 300; text-transform: uppercase; }
        .cal-date { font-size: 8rem; font-weight: 900; line-height: 1; color: #2d3436; }
        .cal-year { font-size: 1.2rem; font-weight: 700; color: #d63031; }
        .cal-lunar { font-size: 1.1rem; color: #636e72; margin-top: 5px; font-family: 'Dancing Script', cursive; }

        .calendar-page.special-date {
            background: #b30000; border: 2px solid #ffd700;
            background-image: radial-gradient(#d63031 15%, transparent 16%);
        }
        .calendar-page.special-date::before { background: #800000; border-bottom: 2px dashed gold; }
        .calendar-page.special-date .cal-month { color: #ffd700; font-weight: bold; }
        .calendar-page.special-date .cal-date { color: #ffd700; text-shadow: 2px 2px 0px #800000; }
        .calendar-page.special-date .cal-year { color: #fff; opacity: 0.8; }
        .calendar-page.special-date .cal-lunar { color: #fff; font-size: 1.4rem; font-weight: bold; text-shadow: 0 2px 5px rgba(0,0,0,0.5); }

        @keyframes tearOff {
            0% { transform: rotate(0deg); }
            20% { transform: rotate(-10deg) skewX(5deg); }
            100% { transform: rotate(60deg) translateY(200px) translateX(400px); opacity: 0; }
        }
        .tearing { animation: tearOff 0.9s ease-in forwards; }

        /* --- UI COUNTDOWN --- */
        #countdown-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; justify-content: center; align-items: center;
            font-size: 15rem; font-weight: 900; color: #fff;
            z-index: 60; 
            text-shadow: 0 0 50px rgba(255,255,255,0.8);
            font-family: 'Montserrat', sans-serif;
            pointer-events: none;
        }
        @keyframes zoomTick { 
            0% { transform: scale(0.5); opacity: 0; } 
            50% { opacity: 1; transform: scale(1.2); } 
            100% { transform: scale(2); opacity: 0; } 
        }

        /* --- UI L√å X√å --- */
        #lixi-btn {
            position: absolute; bottom: 20%; left: 50%; transform: translate(-50%, 0);
            padding: 15px 60px; 
            background: linear-gradient(45deg, #c0392b, #d35400);
            border: 2px solid gold; border-radius: 50px; color: #fff; font-weight: 900;
            font-size: 1.5rem; cursor: pointer; z-index: 20;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8), inset 0 0 10px rgba(255,215,0,0.5);
            display: none; 
            animation: popIn 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            transition: transform 0.2s;
        }
        #lixi-btn:active { transform: translate(-50%, 0) scale(0.95); }
        @keyframes popIn { from { transform: translate(-50%, 100px) scale(0); opacity: 0; } to { transform: translate(-50%, 0) scale(1); opacity: 1; } }

        #lixi-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); z-index: 30;
            display: none; justify-content: center; align-items: center;
            transition: backdrop-filter 1s ease, background 1s ease;
            overflow-y: auto; 
        }
        .envelopes-container {
            display: flex; gap: 30px; perspective: 1000px;
            flex-wrap: wrap; justify-content: center; width: 100%;
            padding-top: 50px; padding-bottom: 50px; 
        }
        .envelope-wrapper {
            width: 120px; height: 180px; position: relative; cursor: pointer;
            transform-style: preserve-3d; transition: transform 0.3s ease;
        }
        .envelope-wrapper:hover { transform: translateY(-10px); }

        .env-body {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 85%;
            background: #c0392b; border-radius: 0 0 10px 10px;
            border: 2px solid #b33939; border-top: none; z-index: 2; overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        .env-body::before { 
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: radial-gradient(circle, #a93226 10%, transparent 10%);
            background-size: 20px 20px; opacity: 0.3;
        }
        .env-body .coin-deco {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3rem; color: rgba(255, 215, 0, 0.3); font-weight: 900;
        }
        .env-flap {
            position: absolute; top: 0; left: 0; width: 100%; height: 15%; 
            background: #d63031; border-radius: 10px 10px 0 0;
            border: 2px solid #b33939; border-bottom: none;
            transform-origin: bottom; z-index: 3;
            transition: transform 0.4s ease-in-out; border-bottom: 2px solid gold;
        }
        .env-paper {
            position: absolute; top: 15%; left: 10px; right: 10px; height: 70%;
            background: #fffdf5; z-index: 1; border-radius: 5px;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex; justify-content: center; align-items: center;
            font-size: 0.8rem; color: #333; overflow: hidden;
        }
        .envelope-wrapper.active { pointer-events: none; } 
        .envelope-wrapper.active .env-flap { transform: rotateX(180deg); z-index: 0; }
        .envelope-wrapper.active .env-paper { z-index: 10; animation: paperUpAndFlip 1s forwards 0.3s; }
        @keyframes paperUpAndFlip {
            0% { transform: translateY(0) scale(1) rotateY(0); }
            50% { transform: translateY(-120px) scale(1) rotateY(0); } 
            100% { transform: translateY(-200px) scale(3) rotateY(90deg); opacity: 0; } 
        }
        @keyframes flyIn { from { transform: translateY(600px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        /* POPUP TH∆Ø RESPONSIVE */
        #letter-modal {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%) rotateY(90deg); 
            width: 85%; max-width: 600px; max-height: 70vh; overflow-y: auto;
            background: #fffdf5 url('https://www.transparenttextures.com/patterns/cream-paper.png');
            padding: 25px; border-radius: 15px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.9);
            font-family: 'Patrick Hand', cursive; font-size: 1.5rem; color: #2c3e50;
            z-index: 40; text-align: center; line-height: 1.5;
            border: 6px double #d63031; opacity: 0;
            transition: transform 0.5s ease-out, opacity 0.5s;
        }
        #letter-modal.show-flip { transform: translate(-50%, -50%) rotateY(0deg); opacity: 1; }
        .close-btn {
            margin-top: 20px; padding: 10px 30px; background: #d63031; color: #fff;
            border: none; border-radius: 8px; cursor: pointer; font-size: 1.2rem;
            box-shadow: 0 5px 15px rgba(214, 48, 49, 0.4);
            font-family: 'Montserrat', sans-serif; display: inline-block;
        }

        /* M√ÄN H√åNH CU·ªêI */
        #final-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 50; pointer-events: none;
        }
        .final-text {
            font-size: 3.5rem; font-weight: 900; color: #fff; text-align: center;
            text-shadow: 0 0 20px #ff0055; margin-bottom: 20px;
        }
        .wavy-char { display: inline-block; animation: textWave 2.5s ease-in-out infinite; }
        @keyframes textWave { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-12px); } }

        #love-message {
            font-family: 'Pacifico', cursive; font-size: 4.5rem;
            background: linear-gradient(to right, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 20, 147, 0.6);
            opacity: 0; transform: scale(0.5);
            transition: all 1.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin-top: 20px; z-index: 60;
        }
        #love-message.show-love { opacity: 1; transform: scale(1); animation: heartBeat 1.2s infinite alternate; }
        @keyframes heartBeat {
            0% { transform: scale(1); text-shadow: 0 0 30px rgba(255, 20, 147, 0.6); }
            100% { transform: scale(1.1); text-shadow: 0 0 60px rgba(255, 0, 100, 1); filter: brightness(1.2); }
        }

        #redirect-btn {
            margin-top: 40px; padding: 15px 40px; background: #fff; color: #d63031;
            border: 2px solid gold; border-radius: 30px;
            font-size: 1.2rem; font-weight: 700; cursor: pointer;
            opacity: 0; pointer-events: auto; transition: opacity 1.5s ease;
            z-index: 100; font-family: 'Montserrat', sans-serif;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        #redirect-btn.show-btn { opacity: 1; animation: pulseBtn 2s infinite; }

        /* --- TRANG CUSTOM M·ªöI (CANVAS TR·∫ÆNG) --- */
        #my-custom-page {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999; /* ƒê·∫£m b·∫£o n·∫±m tr√™n c√πng */
            display: none; 
            background: #fff; /* ƒê·ªïi th√†nh n·ªÅn tr·∫Øng */
        }
        #final-custom-canvas {
            display: block; width: 100%; height: 100%;
        }

        .final-icon {
            position: absolute; font-size: 2.5rem;
            animation: floatIconFinal 4s infinite ease-in-out;
            opacity: 0; z-index: 52;
        }
        @keyframes floatIconFinal { 
            0% { transform: translateY(100px) rotate(0deg); opacity: 0; } 
            20% { opacity: 1; } 80% { opacity: 1; }
            100% { transform: translateY(-200px) rotate(20deg); opacity: 0; } 
        }

        @media (max-width: 480px) {
            #letter-modal { width: 90%; font-size: 1.3rem; padding: 15px; }
            .start-btn { font-size: 1.2rem; padding: 15px 30px; }
            .envelope-wrapper { width: 100px; height: 150px; }
            .final-text { font-size: 2.2rem !important; } 
            #love-message { font-size: 3rem !important; }
        }
        
    </style>
</head>
<body>

    <audio id="bg-music" playsinline style="display:none">
        <source src="intro.mp4" type="audio/mp4">
        <source src="intro.mp3" type="audio/mpeg">
    </audio>

    <div id="start-overlay">
        <button class="start-btn" onclick="startExperience()">Ch·∫°m v√†o ƒë√¢y n√®eeüßß</button>
    </div>

    <div class="stage-container">
        <div class="canvas-container">
            <canvas id="trails-canvas"></canvas>
            <canvas id="main-canvas"></canvas>
        </div>
    </div>

    <div id="calendar-container"></div>
    <div id="countdown-container"></div>

    <button id="lixi-btn">Nh·∫≠n L√¨ X√¨ N√® üßß</button>
    <div id="lixi-overlay">
        <div class="envelopes-container" id="env-container"></div>
    </div>

    <div id="letter-modal">
        <div id="letter-content"></div>
        <button class="close-btn" onclick="closeLetter()">ƒê√≥ng l·∫°i</button>
    </div>

    <div id="final-screen">
        <div class="final-text">HAPPY NEW YEAR<br>2026 <span style="color:red">‚ô•</span></div>
        <div id="love-message">Happy Forever‚ù§Ô∏è</div>
        <button id="redirect-btn" onclick="goToNextPage()">Xem ti·∫øp nh√©üéÅ</button>
    </div>

    <div id="my-custom-page">
        <canvas id="final-custom-canvas"></canvas>
    </div>

    <script>
        // --- C·∫§U H√åNH D·ªÆ LI·ªÜU ---
        const DATES = [
            { d: 28, m: 12, y: 2025, l: "..." },
            { d: 29, m: 12, y: 2025, l: "ƒê√™m Giao Th·ª´a" },
            { d: "01", m: "01", y: 2026, l: "T·∫øt Nguy√™n ƒê√°n" }
        ];

        // L·ªúI CH√öC M·ªöI (CHUNG H∆†N, X∆ØNG C·∫¨U - T·ªö)
        const LETTERS = [
            "üßß NƒÉm m·ªõi 2026, ch√∫c c·∫≠u m·ªôt nƒÉm r·ª±c r·ª°! Lu√¥n tr√†n ƒë·∫ßy nƒÉng l∆∞·ª£ng, s·ª©c kh·ªèe d·ªìi d√†o v√† g·∫∑p th·∫≠t nhi·ªÅu may m·∫Øn trong cu·ªôc s·ªëng. C·ª© vui v·∫ª v√† c∆∞·ªùi th·∫≠t nhi·ªÅu nh√©!",
            "üéÜ Ch√∫c c·∫≠u m·ªôt nƒÉm h·ªçc t·∫≠p/l√†m vi·ªác th·∫≠t th√†nh c√¥ng. M·ªçi d·ª± ƒë·ªãnh ·∫•p ·ªß ƒë·ªÅu s·∫Ω th√†nh hi·ªán th·ª±c. H√£y tin v√†o b·∫£n th√¢n m√¨nh, c·∫≠u gi·ªèi h∆°n c·∫≠u nghƒ© nhi·ªÅu ƒë·∫•y!",
            "üöÄ Cu·ªôc s·ªëng s·∫Ω c√≥ l√∫c thƒÉng l√∫c tr·∫ßm, nh∆∞ng t·ªõ mong c·∫≠u lu√¥n gi·ªØ v·ªØng tinh th·∫ßn l·∫°c quan. M·ªçi kh√≥ khƒÉn ch·ªâ l√† th·ª≠ th√°ch ƒë·ªÉ ch√∫ng ta tr∆∞·ªüng th√†nh h∆°n th√¥i. C·ªë l√™n nh√©!",
            "ü•∞ Ch√∫c c·∫≠u nƒÉm m·ªõi ng√†y c√†ng xinh ƒë·∫πp/r·∫°ng r·ª°, lu√¥n l√† ch√≠nh m√¨nh v√† t·ªèa s√°ng theo c√°ch ri√™ng. Happy New Year!",
            "ü•≥ G√°c l·∫°i nh·ªØng mu·ªôn phi·ªÅn c·ªßa nƒÉm c≈©, c√πng ƒë√≥n ch√†o m·ªôt nƒÉm m·ªõi v·ªõi th·∫≠t nhi·ªÅu hy v·ªçng m·ªõi. Ch√∫c c·∫≠u t√¨m th·∫•y ni·ªÅm vui trong t·ª´ng ng√†y tr√¥i qua.",
            "üíå L√¨ x√¨ n√†y ch·ª©a ƒë·ª±ng ni·ªÅm tin v√† s·ª± ·ªßng h·ªô t·ªõ d√†nh cho c·∫≠u. Ch√∫c nƒÉm 2026 c·ªßa c·∫≠u s·∫Ω tr·ªçn v·∫πn v√† √Ω nghƒ©a. Happy New Year! ‚ù§Ô∏è"
        ];

        // --- H·ªÜ TH·ªêNG √ÇM THANH C∆† B·∫¢N ---
        const AudioSys = {
            ctx: null,
            init() { 
                if(!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)(); 
                    const buffer = this.ctx.createBuffer(1, 1, 22050);
                    const source = this.ctx.createBufferSource();
                    source.buffer = buffer; source.connect(this.ctx.destination);
                    source.start(0);
                }
            },
            play(type) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                if (type === 'launch') {
                    osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(600, t + 0.8);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.8);
                } else if (type === 'boom') {
                    osc.frequency.setValueAtTime(120, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
                    gain.gain.setValueAtTime(1.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                } else if (type === 'crackle') { 
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(500, t);
                    osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    gain.gain.setValueAtTime(0.2, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                }
                
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(t); osc.stop(t + 2);
            }
        };

        function startExperience() {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('calendar-container').style.display = 'block';
            AudioSys.init();
            
            const music = document.getElementById('bg-music');
            music.volume = 1.0;
            music.play().catch(e => console.log("L·ªói ph√°t nh·∫°c:", e));

            music.onended = function() {
                if (this.src.includes("intro.mp4") || this.currentSrc.includes("intro.mp4")) {
                    this.src = "main.mp3"; this.load(); this.play().catch(e=>{});
                } else if (this.src.includes("main.mp3") || this.currentSrc.includes("main.mp3")) {
                    this.src = "codoidieu.mp3"; this.loop = true; this.load(); this.play().catch(e=>{});
                }
            };
            initCalendar();
        }

        // --- L·ªäCH ---
        const calContainer = document.getElementById('calendar-container');
        let dateIndex = 0;
        function initCalendar() {
            for (let i = DATES.length - 1; i >= 0; i--) {
                const d = DATES[i];
                const el = document.createElement('div');
                el.className = 'calendar-page'; el.style.zIndex = 100 - i;
                if ( (d.d == 29) || (d.d == "01" && d.m == "01") ) el.classList.add('special-date');
                el.innerHTML = `<div class="cal-month">Th√°ng ${d.m}</div><div class="cal-date">${d.d}</div><div class="cal-year">${d.y}</div><div class="cal-lunar">${d.l}</div>`;
                calContainer.appendChild(el);
            }
            setTimeout(tearNextPage, 1000);
        }

        function tearNextPage() {
            if (dateIndex < DATES.length - 1) { 
                const pageToTear = calContainer.children[DATES.length - 1 - dateIndex];
                if(pageToTear) { pageToTear.classList.add('tearing'); AudioSys.play('launch'); }
                dateIndex++; setTimeout(tearNextPage, 1000); 
            } else {
                setTimeout(startCountdown, 800);
            }
        }

        // --- ƒê·∫æM NG∆Ø·ª¢C ---
        function startCountdown() {
            calContainer.style.display = 'none';
            const countDiv = document.getElementById('countdown-container');
            countDiv.style.display = 'flex';
            let count = 3;

            function tick() {
                if (count > 0) {
                    countDiv.innerText = count;
                    countDiv.style.animation = 'none';
                    countDiv.offsetHeight; 
                    countDiv.style.animation = 'zoomTick 0.9s ease-out';
                    count--;
                    setTimeout(tick, 1000);
                } else {
                    countDiv.style.display = 'none';
                    
                    // --- GIAI ƒêO·∫†N 1: B·∫ÆN PH√ÅO HOA ---
                    startFireworksShow();

                    // --- GIAI ƒêO·∫†N 2: CH·ªú M·ªòT L√öC R·ªíI HI·ªÜN N√öT L√å X√å ---
                    // ƒê√£ xo√° ph·∫ßn Drone, thay b·∫±ng hi·ªÉn th·ªã n√∫t tr·ª±c ti·∫øp
                    setTimeout(() => {
                        store.setState({
                            config: { ...store.state.config, autoLaunch: false }
                        });
                        // Hi·ªán n√∫t l√¨ x√¨
                        document.getElementById('lixi-btn').style.display = 'block';
                    }, 15000); // Ch·ªù 15 gi√¢y ph√°o hoa r·ªìi hi·ªán n√∫t
                }
            }
            tick();
        }

        // --- PH·∫¶N PH√ÅO HOA N√ÇNG C·∫§P (GI·ªÆ NGUY√äN) ---
        (function(global){'use strict';var key={fullscreenEnabled:0,fullscreenElement:1,requestFullscreen:2,exitFullscreen:3,fullscreenchange:4,fullscreenerror:5};var webkit=['webkitFullscreenEnabled','webkitFullscreenElement','webkitRequestFullscreen','webkitExitFullscreen','webkitfullscreenchange','webkitfullscreenerror'];var moz=['mozFullScreenEnabled','mozFullScreenElement','mozRequestFullScreen','mozCancelFullScreen','mozfullscreenchange','mozfullscreenerror'];var ms=['msFullscreenEnabled','msFullscreenElement','msRequestFullscreen','msExitFullscreen','MSFullscreenChange','MSFullscreenError'];var doc=typeof window!=='undefined'&&typeof window.document!=='undefined'?window.document:{};var vendor='fullscreenEnabled'in doc&&Object.keys(key)||webkit[0]in doc&&webkit||moz[0]in doc&&moz||ms[0]in doc&&ms||[];var fscreen={requestFullscreen:function requestFullscreen(element){return element[vendor[key.requestFullscreen]]();},requestFullscreenFunction:function requestFullscreenFunction(element){return element[vendor[key.requestFullscreen]];},get exitFullscreen(){return doc[vendor[key.exitFullscreen]].bind(doc);},addEventListener:function addEventListener(type,handler,options){return doc.addEventListener(vendor[key[type]],handler,options);},removeEventListener:function removeEventListener(type,handler){return doc.removeEventListener(vendor[key[type]],handler);},get fullscreenEnabled(){return Boolean(doc[vendor[key.fullscreenEnabled]]);},set fullscreenEnabled(val){},get fullscreenElement(){return doc[vendor[key.fullscreenElement]];},set fullscreenElement(val){},get onfullscreenchange(){return doc[('on'+vendor[key.fullscreenchange]).toLowerCase()];},set onfullscreenchange(handler){return doc[('on'+vendor[key.fullscreenchange]).toLowerCase()]=handler;},get onfullscreenerror(){return doc[('on'+vendor[key.fullscreenerror]).toLowerCase()];},set onfullscreenerror(handler){return doc[('on'+vendor[key.fullscreenerror]).toLowerCase()]=handler;}};global.fscreen=fscreen;})(window);

        const MyMath = (function MyMathFactory(Math) {
            const MyMath = {};
            MyMath.toDeg = 180 / Math.PI; MyMath.toRad = Math.PI / 180; MyMath.halfPI = Math.PI / 2; MyMath.twoPI = Math.PI * 2;
            MyMath.dist = (width, height) => { return Math.sqrt(width * width + height * height); };
            MyMath.pointDist = (x1, y1, x2, y2) => { const distX = x2 - x1; const distY = y2 - y1; return Math.sqrt(distX * distX + distY * distY); };
            MyMath.angle = (width, height) => MyMath.halfPI + Math.atan2(height, width);
            MyMath.pointAngle = (x1, y1, x2, y2) => MyMath.halfPI + Math.atan2(y2 - y1, x2 - x1);
            MyMath.splitVector = (speed, angle) => ({ x: Math.sin(angle) * speed, y: -Math.cos(angle) * speed, });
            MyMath.random = (min, max) => Math.random() * (max - min) + min;
            MyMath.randomInt = (min, max) => ((Math.random() * (max - min + 1)) | 0) + min;
            MyMath.randomChoice = function randomChoice(choices) { if (arguments.length === 1 && Array.isArray(choices)) { return choices[(Math.random() * choices.length) | 0]; } return arguments[(Math.random() * arguments.length) | 0]; };
            MyMath.clamp = function clamp(num, min, max) { return Math.min(Math.max(num, min), max); };
            return MyMath;
        })(Math);

        const Ticker = (function TickerFactory(window) {
            "use strict"; const Ticker = {};
            Ticker.addListener = function addListener(callback) { if (typeof callback !== "function") throw "Ticker error"; listeners.push(callback); if (!started) { started = true; queueFrame(); } };
            let started = false; let lastTimestamp = 0; let listeners = [];
            function queueFrame() { if (window.requestAnimationFrame) { requestAnimationFrame(frameHandler); } else { webkitRequestAnimationFrame(frameHandler); } }
            function frameHandler(timestamp) { let frameTime = timestamp - lastTimestamp; lastTimestamp = timestamp; if (frameTime < 0) { frameTime = 17; } else if (frameTime > 68) { frameTime = 68; } listeners.forEach((listener) => listener.call(window, frameTime, frameTime / 16.6667)); queueFrame(); }
            return Ticker;
        })(window);

        const Stage = (function StageFactory(window, document, Ticker) {
            "use strict"; let lastTouchTimestamp = 0;
            function Stage(canvas) {
                if (typeof canvas === "string") canvas = document.getElementById(canvas);
                this.canvas = canvas; this.ctx = canvas.getContext("2d"); this.canvas.style.touchAction = "none";
                this.speed = 1; this.dpr = (window.devicePixelRatio || 1) / (this.ctx.backingStorePixelRatio || 1);
                this.width = canvas.width; this.height = canvas.height; this.naturalWidth = this.width * this.dpr; this.naturalHeight = this.height * this.dpr;
                if (this.width !== this.naturalWidth) { this.canvas.width = this.naturalWidth; this.canvas.height = this.naturalHeight; this.canvas.style.width = this.width + "px"; this.canvas.style.height = this.height + "px"; }
                Stage.stages.push(this);
                this._listeners = { resize: [], pointerstart: [], pointermove: [], pointerend: [], lastPointerPos: { x: 0, y: 0 }, };
            }
            Stage.stages = [];
            Stage.prototype.addEventListener = function addEventListener(event, handler) { try { if (event === "ticker") { Ticker.addListener(handler); } else { this._listeners[event].push(handler); } } catch (e) { throw "Invalid Event"; } };
            Stage.prototype.dispatchEvent = function dispatchEvent(event, val) { const listeners = this._listeners[event]; if (listeners) { listeners.forEach((listener) => listener.call(this, val)); } };
            Stage.prototype.resize = function resize(w, h) { this.width = w; this.height = h; this.naturalWidth = w * this.dpr; this.naturalHeight = h * this.dpr; this.canvas.width = this.naturalWidth; this.canvas.height = this.naturalHeight; this.canvas.style.width = w + "px"; this.canvas.style.height = h + "px"; this.dispatchEvent("resize"); };
            Stage.windowToCanvas = function windowToCanvas(canvas, x, y) { const bbox = canvas.getBoundingClientRect(); return { x: (x - bbox.left) * (canvas.width / bbox.width), y: (y - bbox.top) * (canvas.height / bbox.height), }; };
            Stage.mouseHandler = function mouseHandler(evt) { if (Date.now() - lastTouchTimestamp < 500) { return; } let type = "start"; if (evt.type === "mousemove") { type = "move"; } else if (evt.type === "mouseup") { type = "end"; } Stage.stages.forEach((stage) => { const pos = Stage.windowToCanvas(stage.canvas, evt.clientX, evt.clientY); stage.pointerEvent(type, pos.x / stage.dpr, pos.y / stage.dpr); }); };
            Stage.touchHandler = function touchHandler(evt) { lastTouchTimestamp = Date.now(); let type = "start"; if (evt.type === "touchmove") { type = "move"; } else if (evt.type === "touchend") { type = "end"; } Stage.stages.forEach((stage) => { for (let touch of Array.from(evt.changedTouches)) { let pos; if (type !== "end") { pos = Stage.windowToCanvas(stage.canvas, touch.clientX, touch.clientY); stage._listeners.lastPointerPos = pos; if (type === "start") stage.pointerEvent("move", pos.x / stage.dpr, pos.y / stage.dpr); } else { pos = stage._listeners.lastPointerPos; } stage.pointerEvent(type, pos.x / stage.dpr, pos.y / stage.dpr); } }); };
            Stage.prototype.pointerEvent = function pointerEvent(type, x, y) { const evt = { type: type, x: x, y: y, }; evt.onCanvas = x >= 0 && x <= this.width && y >= 0 && y <= this.height; this.dispatchEvent("pointer" + type, evt); };
            document.addEventListener("mousedown", Stage.mouseHandler); document.addEventListener("mousemove", Stage.mouseHandler); document.addEventListener("mouseup", Stage.mouseHandler); document.addEventListener("touchstart", Stage.touchHandler); document.addEventListener("touchmove", Stage.touchHandler); document.addEventListener("touchend", Stage.touchHandler);
            return Stage;
        })(window, document, Ticker);

        // --- Logic Ph√°o Hoa Ch√≠nh ---
        const IS_MOBILE = window.innerWidth <= 640;
        const IS_DESKTOP = window.innerWidth > 800;
        const MAX_WIDTH = 7680; const MAX_HEIGHT = 4320; const GRAVITY = 0.9;
        let simSpeed = 1;
        
        let stageW, stageH;
        let quality = 3; 
        let isLowQuality = false; let isNormalQuality = false; let isHighQuality = true;
        const QUALITY_LOW=1, QUALITY_NORMAL=2, QUALITY_HIGH=3;
        const SKY_LIGHT_NONE=0, SKY_LIGHT_DIM=1, SKY_LIGHT_NORMAL=2;
        const COLOR = { Red: "#ff0043", Green: "#14fc56", Blue: "#1e7fff", Purple: "#e60aff", Gold: "#ffbf36", White: "#ffffff", };
        const INVISIBLE = "_INVISIBLE_"; const PI_2 = Math.PI * 2; const PI_HALF = Math.PI * 0.5;

        // Init Stages
        const trailsStage = new Stage("trails-canvas");
        const mainStage = new Stage("main-canvas");
        const stages = [trailsStage, mainStage];

        // Store c·∫•u h√¨nh
        const store = {
            state: {
                paused: true,
                soundEnabled: true,
                menuOpen: false,
                config: { quality: "3", shell: "Random", size: IS_DESKTOP ? "3" : "2", autoLaunch: true, finale: false, skyLighting: "2", hideControls: true, longExposure: false, scaleFactor: IS_MOBILE ? 0.9 : 1 }
            },
            setState(nextState) { this.state = Object.assign({}, this.state, nextState); },
        };

        const COLOR_NAMES = Object.keys(COLOR);
        const COLOR_CODES = COLOR_NAMES.map(name => COLOR[name]);
        const COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE];
        const COLOR_TUPLES = {};
        COLOR_CODES.forEach(hex => { COLOR_TUPLES[hex] = { r: parseInt(hex.substr(1, 2), 16), g: parseInt(hex.substr(3, 2), 16), b: parseInt(hex.substr(5, 2), 16), }; });

        function randomColorSimple() { return COLOR_CODES[(Math.random() * COLOR_CODES.length) | 0]; }
        let lastColor;
        function randomColor(options) {
            const notSame = options && options.notSame; const notColor = options && options.notColor; const limitWhite = options && options.limitWhite;
            let color = randomColorSimple();
            if (limitWhite && color === COLOR.White && Math.random() < 0.6) color = randomColorSimple();
            if (notSame) { while (color === lastColor) color = randomColorSimple(); } else if (notColor) { while (color === notColor) color = randomColorSimple(); }
            lastColor = color; return color;
        }
        function whiteOrGold() { return Math.random() < 0.5 ? COLOR.Gold : COLOR.White; }
        function makePistilColor(shellColor) { return shellColor === COLOR.White || shellColor === COLOR.Gold ? randomColor({ notColor: shellColor }) : whiteOrGold(); }

        // Shell Types
        const crysanthemumShell = (size=1) => {
            const glitter = Math.random() < 0.25; const singleColor = Math.random() < 0.72;
            const color = singleColor ? randomColor({ limitWhite: true }) : [randomColor(), randomColor({ notSame: true })];
            const pistil = singleColor && Math.random() < 0.42; const pistilColor = pistil && makePistilColor(color);
            const secondColor = singleColor && (Math.random() < 0.2 || color === COLOR.White) ? pistilColor || randomColor({ notColor: color, limitWhite: true }) : null;
            const streamers = !pistil && color !== COLOR.White && Math.random() < 0.42;
            let starDensity = glitter ? 1.1 : 1.25; if (isHighQuality) starDensity = 1.2;
            return { shellSize: size, spreadSize: 300 + size * 100, starLife: 900 + size * 200, starDensity, color, secondColor, glitter: glitter ? "light" : "", glitterColor: whiteOrGold(), pistil, pistilColor, streamers, };
        };
        const ghostShell = (size=1) => { const shell = crysanthemumShell(size); shell.starLife *= 1.5; let ghostColor = randomColor({ notColor: COLOR.White }); shell.streamers = true; shell.color = INVISIBLE; shell.secondColor = ghostColor; shell.glitter = ""; return shell; };
        const strobeShell = (size=1) => { const color = randomColor({ limitWhite: true }); return { shellSize: size, spreadSize: 280 + size * 92, starLife: 1100 + size * 200, starLifeVariation: 0.4, starDensity: 1.1, color, glitter: "light", glitterColor: COLOR.White, strobe: true, strobeColor: Math.random() < 0.5 ? COLOR.White : null, pistil: Math.random() < 0.5, pistilColor: makePistilColor(color), }; };
        const palmShell = (size=1) => { const color = randomColor(); const thick = Math.random() < 0.5; return { shellSize: size, color, spreadSize: 250 + size * 75, starDensity: thick ? 0.15 : 0.4, starLife: 1800 + size * 200, glitter: thick ? "thick" : "heavy", }; };
        const ringShell = (size=1) => { const color = randomColor(); const pistil = Math.random() < 0.75; return { shellSize: size, ring: true, color, spreadSize: 300 + size * 100, starLife: 900 + size * 200, starCount: 2.2 * PI_2 * (size + 1), pistil, pistilColor: makePistilColor(color), glitter: !pistil ? "light" : "", glitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White, streamers: Math.random() < 0.3, }; };
        const crossetteShell = (size=1) => { const color = randomColor({ limitWhite: true }); return { shellSize: size, spreadSize: 300 + size * 100, starLife: 750 + size * 160, starLifeVariation: 0.4, starDensity: 0.85, color, crossette: true, pistil: Math.random() < 0.5, pistilColor: makePistilColor(color), }; };
        const floralShell = (size=1) => ({ shellSize: size, spreadSize: 300 + size * 120, starDensity: 0.12, starLife: 500 + size * 50, starLifeVariation: 0.5, color: Math.random() < 0.65 ? "random" : Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({ notSame: true })], floral: true, });
        const fallingLeavesShell = (size=1) => ({ shellSize: size, color: INVISIBLE, spreadSize: 300 + size * 120, starDensity: 0.12, starLife: 500 + size * 50, starLifeVariation: 0.5, glitter: "medium", glitterColor: COLOR.Gold, fallingLeaves: true, });
        const willowShell = (size=1) => ({ shellSize: size, spreadSize: 300 + size * 100, starDensity: 0.6, starLife: 3000 + size * 300, glitter: "willow", glitterColor: COLOR.Gold, color: INVISIBLE, });
        const crackleShell = (size=1) => { const color = Math.random() < 0.75 ? COLOR.Gold : randomColor(); return { shellSize: size, spreadSize: 380 + size * 75, starDensity: 1, starLife: 600 + size * 100, starLifeVariation: 0.32, glitter: "light", glitterColor: COLOR.Gold, color, crackle: true, pistil: Math.random() < 0.65, pistilColor: makePistilColor(color), }; };
        const horsetailShell = (size=1) => { const color = randomColor(); return { shellSize: size, horsetail: true, color, spreadSize: 250 + size * 38, starDensity: 0.9, starLife: 2500 + size * 300, glitter: "medium", glitterColor: Math.random() < 0.5 ? whiteOrGold() : color, strobe: color === COLOR.White, }; };

        function randomShellName() { return Math.random() < 0.5 ? "Crysanthemum" : shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0]; }
        function randomShell(size) { return shellTypes[randomShellName()](size); }
        function shellFromConfig(size) { return shellTypes[store.state.config.shell](size); }
        const fastShellBlacklist = ["Falling Leaves", "Floral", "Willow"];
        function randomFastShell() {
            const isRandom = store.state.config.shell === "Random";
            let shellName = isRandom ? randomShellName() : store.state.config.shell;
            if (isRandom) { while (fastShellBlacklist.includes(shellName)) shellName = randomShellName(); }
            return shellTypes[shellName];
        }
        const shellTypes = { Random: randomShell, Crackle: crackleShell, Crossette: crossetteShell, Crysanthemum: crysanthemumShell, "Falling Leaves": fallingLeavesShell, Floral: floralShell, Ghost: ghostShell, "Horse Tail": horsetailShell, Palm: palmShell, Ring: ringShell, Strobe: strobeShell, Willow: willowShell, };
        const shellNames = Object.keys(shellTypes);

        // Position & Launch Logic
        function fitShellPositionInBoundsH(position) { const edge = 0.18; return (1 - edge * 2) * position + edge; }
        function fitShellPositionInBoundsV(position) { return position * 0.75; }
        function getRandomShellPositionH() { return fitShellPositionInBoundsH(Math.random()); }
        function getRandomShellPositionV() { return fitShellPositionInBoundsV(Math.random()); }
        function getRandomShellSize() {
            const baseSize = +store.state.config.size; const maxVariance = Math.min(2.5, baseSize);
            const variance = Math.random() * maxVariance;
            const size = baseSize - variance;
            const height = maxVariance === 0 ? Math.random() : 1 - variance / maxVariance;
            const centerOffset = Math.random() * (1 - height * 0.65) * 0.5;
            const x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset;
            return { size, x: fitShellPositionInBoundsH(x), height: fitShellPositionInBoundsV(height), };
        }
        function launchShellFromConfig(event) {
            const shell = new Shell(shellFromConfig(+store.state.config.size));
            const w = mainStage.width; const h = mainStage.height;
            shell.launch( event ? event.x / w : getRandomShellPositionH(), event ? 1 - event.y / h : getRandomShellPositionV() );
        }

        // Sequences
        function seqRandomShell() {
            const size = getRandomShellSize(); const shell = new Shell(shellFromConfig(size.size));
            shell.launch(size.x, size.height);
            let extraDelay = shell.starLife; if (shell.fallingLeaves) extraDelay = 4600;
            return 900 + Math.random() * 600 + extraDelay;
        }
        function seqRandomFastShell() {
            const shellType = randomFastShell(); const size = getRandomShellSize();
            const shell = new Shell(shellType(size.size)); shell.launch(size.x, size.height);
            return 900 + Math.random() * 600 + shell.starLife;
        }
        function seqTwoRandom() {
            const size1 = getRandomShellSize(); const size2 = getRandomShellSize();
            const shell1 = new Shell(shellFromConfig(size1.size)); const shell2 = new Shell(shellFromConfig(size2.size));
            shell1.launch(0.3 + (Math.random()*0.2-0.1), size1.height);
            setTimeout(() => { shell2.launch(0.7 + (Math.random()*0.2-0.1), size2.height); }, 100);
            return 900 + Math.random() * 600 + Math.max(shell1.starLife, shell2.starLife);
        }
        function seqTriple() {
            const shellType = randomFastShell(); const baseSize = +store.state.config.size; const smallSize = Math.max(0, baseSize - 1.25);
            const shell1 = new Shell(shellType(baseSize)); shell1.launch(0.5 + (Math.random()*0.08-0.04), 0.7);
            setTimeout(() => { const shell2 = new Shell(shellType(smallSize)); shell2.launch(0.2 + (Math.random()*0.08-0.04), 0.1); }, 1000 + Math.random() * 400);
            setTimeout(() => { const shell3 = new Shell(shellType(smallSize)); shell3.launch(0.8 + (Math.random()*0.08-0.04), 0.1); }, 1000 + Math.random() * 400);
            return 4000;
        }
        function seqPyramid() {
            const barrageCountHalf = IS_DESKTOP ? 7 : 4; const largeSize = +store.state.config.size; const smallSize = Math.max(0, largeSize - 3);
            const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell; const randomSpecialShell = randomShell;
            function launchShell(x, useSpecial) {
                const isRandom = store.state.config.shell === "Random";
                let shellType = isRandom ? useSpecial ? randomSpecialShell : randomMainShell : shellTypes[store.state.config.shell];
                const shell = new Shell(shellType(useSpecial ? largeSize : smallSize));
                shell.launch(x, useSpecial ? 0.75 : (x <= 0.5 ? x / 0.5 : (1 - x) / 0.5) * 0.42);
            }
            let count = 0; let delay = 0;
            while (count <= barrageCountHalf) {
                if (count === barrageCountHalf) { setTimeout(() => { launchShell(0.5, true); }, delay); } else {
                    const offset = (count / barrageCountHalf) * 0.5; const delayOffset = Math.random() * 30 + 30;
                    setTimeout(() => { launchShell(offset, false); }, delay); setTimeout(() => { launchShell(1 - offset, false); }, delay + delayOffset);
                }
                count++; delay += 200;
            }
            return 3400 + barrageCountHalf * 250;
        }
        function seqSmallBarrage() {
            seqSmallBarrage.lastCalled = Date.now();
            const barrageCount = IS_DESKTOP ? 11 : 5; const specialIndex = IS_DESKTOP ? 3 : 1;
            const shellSize = Math.max(0, +store.state.config.size - 2);
            const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell; const randomSpecialShell = randomFastShell();
            function launchShell(x, useSpecial) {
                const isRandom = store.state.config.shell === "Random";
                let shellType = isRandom ? useSpecial ? randomSpecialShell : randomMainShell : shellTypes[store.state.config.shell];
                const shell = new Shell(shellType(shellSize)); shell.launch(x, ((Math.cos(x * 5 * Math.PI + PI_HALF) + 1) / 2) * 0.75);
            }
            let count = 0; let delay = 0;
            while (count < barrageCount) {
                if (count === 0) { launchShell(0.5, false); count += 1; } else {
                    const offset = (count + 1) / barrageCount / 2; const delayOffset = Math.random() * 30 + 30; const useSpecial = count === specialIndex;
                    setTimeout(() => { launchShell(0.5 + offset, useSpecial); }, delay); setTimeout(() => { launchShell(0.5 - offset, useSpecial); }, delay + delayOffset);
                    count += 2;
                }
                delay += 200;
            }
            return 3400 + barrageCount * 120;
        }
        seqSmallBarrage.cooldown = 15000; seqSmallBarrage.lastCalled = Date.now();

        const sequences = [seqRandomShell, seqTwoRandom, seqTriple, seqPyramid, seqSmallBarrage];

        // ----------------------------------------------------------------------------------------
        // --- LOGIC TR√åNH T·ª∞ B·∫ÆN M·ªöI ---
        // ----------------------------------------------------------------------------------------
        let seqStep = 0; 

        function startSequence() {
            try {
                // B∆Ø·ªöC 1: B·∫Øn 1 vi√™n duy nh·∫•t ·ªü trung t√¢m
                if (seqStep === 0) {
                    seqStep++;
                    const shell = new Shell(crysanthemumShell(+store.state.config.size));
                    shell.launch(0.5, 0.5);
                    return 1500; 
                }

                // B∆Ø·ªöC 2: B·∫Øn ph∆∞∆°ng ngang trung t√¢m tr∆∞·ªõc
                if (seqStep === 1) {
                    seqStep++;
                    const size = +store.state.config.size;
                    const shell1 = new Shell(crysanthemumShell(size)); shell1.launch(0.5, 0.7);
                    setTimeout(() => { const s = new Shell(crysanthemumShell(size)); s.launch(0.4, 0.6); }, 200);
                    setTimeout(() => { const s = new Shell(crysanthemumShell(size)); s.launch(0.6, 0.6); }, 200);
                    return 1200;
                }

                // B∆Ø·ªöC 3: 2 b√™n tƒÉng d·∫ßn (d·ªìn) v·ªÅ trung t√¢m
                if (seqStep === 2) {
                    seqStep++;
                    const size = +store.state.config.size;
                    // Lo·∫°t 1: Ngo√†i c√πng
                    const sL1 = new Shell(randomShell(size)); sL1.launch(0.1, 0.5);
                    const sR1 = new Shell(randomShell(size)); sR1.launch(0.9, 0.5);
                    
                    // Lo·∫°t 2: Ti·∫øn v√†o gi·ªØa
                    setTimeout(() => {
                        const sL2 = new Shell(randomShell(size)); sL2.launch(0.3, 0.65);
                        const sR2 = new Shell(randomShell(size)); sR2.launch(0.7, 0.65);
                    }, 400);

                    // Lo·∫°t 3: Ch·ªët h·∫° ·ªü gi·ªØa
                    setTimeout(() => {
                        const sMid = new Shell(crysanthemumShell(size)); sMid.launch(0.5, 0.8);
                    }, 800);

                    return 2000;
                }

                // B∆Ø·ªöC 4: B·∫Øn l·ªôn x·ªôn (Chaos mode) - TƒÉng t·ªëc
                const rand = Math.random();
                if (rand < 0.15 && Date.now() - seqSmallBarrage.lastCalled > seqSmallBarrage.cooldown) return seqSmallBarrage();
                if (rand < 0.25) return seqPyramid(); 
                if (rand < 0.6) return seqRandomShell();
                else if (rand < 0.8) return seqTwoRandom();
                else return seqTriple();

            } catch (err) {
                console.error("L·ªói trong sequence:", err);
                return 2000;
            }
        }

        let currentFrame = 0;
        let autoLaunchTime = 0;

        function update(frameTime, lag) {
            if (store.state.paused) return;
            const width = stageW; const height = stageH; const timeStep = frameTime * simSpeed; const speed = simSpeed * lag;
            currentFrame++;
            
            // --- C·∫¨P NH·∫¨T T·ªêC ƒê·ªò B·∫ÆN ---
            if (store.state.config.autoLaunch) { 
                autoLaunchTime -= timeStep; 
                if (autoLaunchTime <= 0) {
                    let nextDelay = startSequence();
                    // N·∫øu g·∫∑p l·ªói ho·∫∑c tr·∫£ v·ªÅ NaN th√¨ g√°n m·∫∑c ƒë·ªãnh
                    if (!nextDelay || isNaN(nextDelay)) nextDelay = 2000;
                    
                    // Nh√¢n v·ªõi 0.7 ƒë·ªÉ tƒÉng t·ªëc ƒë·ªô b·∫Øn (gi·∫£m th·ªùi gian ch·ªù)
                    autoLaunchTime = nextDelay * 0.7; 
                }
            }
            
            const starDrag = 1 - (1 - Star.airDrag) * speed; const starDragHeavy = 1 - (1 - Star.airDragHeavy) * speed; const sparkDrag = 1 - (1 - Spark.airDrag) * speed; const gAcc = (timeStep / 1000) * GRAVITY;
            COLOR_CODES_W_INVIS.forEach(color => {
                const stars = Star.active[color];
                for (let i = stars.length - 1; i >= 0; i--) {
                    const star = stars[i];
                    if (star.updateFrame === currentFrame) continue;
                    star.updateFrame = currentFrame; star.life -= timeStep;
                    if (star.life <= 0) { stars.splice(i, 1); Star.returnInstance(star); } else {
                        const burnRate = Math.pow(star.life / star.fullLife, 0.5); const burnRateInverse = 1 - burnRate;
                        star.prevX = star.x; star.prevY = star.y; star.x += star.speedX * speed; star.y += star.speedY * speed;
                        if (!star.heavy) { star.speedX *= starDrag; star.speedY *= starDrag; } else { star.speedX *= starDragHeavy; star.speedY *= starDragHeavy; }
                        star.speedY += gAcc;
                        if (star.spinRadius) { star.spinAngle += star.spinSpeed * speed; star.x += Math.sin(star.spinAngle) * star.spinRadius * speed; star.y += Math.cos(star.spinAngle) * star.spinRadius * speed; }
                        if (star.sparkFreq) {
                            star.sparkTimer -= timeStep;
                            while (star.sparkTimer < 0) {
                                star.sparkTimer += star.sparkFreq * 0.75 + star.sparkFreq * burnRateInverse * 4;
                                Spark.add(star.x, star.y, star.sparkColor, Math.random() * PI_2, Math.random() * star.sparkSpeed * burnRate, star.sparkLife * 0.8 + Math.random() * star.sparkLifeVariation * star.sparkLife);
                            }
                        }
                        if (star.life < star.transitionTime) {
                            if (star.secondColor && !star.colorChanged) { star.colorChanged = true; star.color = star.secondColor; stars.splice(i, 1); Star.active[star.secondColor].push(star); if (star.secondColor === INVISIBLE) star.sparkFreq = 0; }
                            if (star.strobe) star.visible = Math.floor(star.life / star.strobeFreq) % 3 === 0;
                        }
                    }
                }
                const sparks = Spark.active[color];
                for (let i = sparks.length - 1; i >= 0; i--) {
                    const spark = sparks[i]; spark.life -= timeStep;
                    if (spark.life <= 0) { sparks.splice(i, 1); Spark.returnInstance(spark); } else { spark.prevX = spark.x; spark.prevY = spark.y; spark.x += spark.speedX * speed; spark.y += spark.speedY * speed; spark.speedX *= sparkDrag; spark.speedY *= sparkDrag; spark.speedY += gAcc; }
                }
            });
            render(speed);
        }

        function render(speed) {
            const { dpr } = mainStage; const width = stageW; const height = stageH; const trailsCtx = trailsStage.ctx; const mainCtx = mainStage.ctx;
            if (store.state.config.skyLighting !== SKY_LIGHT_NONE + "") colorSky(speed);
            const scaleFactor = +store.state.config.scaleFactor;
            trailsCtx.scale(dpr * scaleFactor, dpr * scaleFactor); mainCtx.scale(dpr * scaleFactor, dpr * scaleFactor);
            trailsCtx.globalCompositeOperation = "source-over"; trailsCtx.fillStyle = `rgba(0, 0, 0, ${store.state.config.longExposure ? 0.0025 : 0.175 * speed})`; trailsCtx.fillRect(0, 0, width, height);
            mainCtx.clearRect(0, 0, width, height);
            while (BurstFlash.active.length) {
                const bf = BurstFlash.active.pop();
                const burstGradient = trailsCtx.createRadialGradient(bf.x, bf.y, 0, bf.x, bf.y, bf.radius);
                burstGradient.addColorStop(0.024, "rgba(255, 255, 255, 1)"); burstGradient.addColorStop(0.125, "rgba(255, 160, 20, 0.2)"); burstGradient.addColorStop(0.32, "rgba(255, 140, 20, 0.11)"); burstGradient.addColorStop(1, "rgba(255, 120, 20, 0)");
                trailsCtx.fillStyle = burstGradient; trailsCtx.fillRect(bf.x - bf.radius, bf.y - bf.radius, bf.radius * 2, bf.radius * 2); BurstFlash.returnInstance(bf);
            }
            trailsCtx.globalCompositeOperation = "lighten"; trailsCtx.lineWidth = Star.drawWidth; trailsCtx.lineCap = isLowQuality ? "square" : "round";
            mainCtx.strokeStyle = "#fff"; mainCtx.lineWidth = 1; mainCtx.beginPath();
            COLOR_CODES.forEach(color => {
                const stars = Star.active[color]; trailsCtx.strokeStyle = color; trailsCtx.beginPath();
                stars.forEach(star => { if (star.visible) { trailsCtx.moveTo(star.x, star.y); trailsCtx.lineTo(star.prevX, star.prevY); mainCtx.moveTo(star.x, star.y); mainCtx.lineTo(star.x - star.speedX * 1.6, star.y - star.speedY * 1.6); } });
                trailsCtx.stroke();
            });
            mainCtx.stroke();
            trailsCtx.lineWidth = Spark.drawWidth; trailsCtx.lineCap = "butt";
            COLOR_CODES.forEach(color => {
                const sparks = Spark.active[color]; trailsCtx.strokeStyle = color; trailsCtx.beginPath();
                sparks.forEach(spark => { trailsCtx.moveTo(spark.x, spark.y); trailsCtx.lineTo(spark.prevX, spark.prevY); });
                trailsCtx.stroke();
            });
            trailsCtx.setTransform(1, 0, 0, 1, 0, 0); mainCtx.setTransform(1, 0, 0, 1, 0, 0);
        }

        const currentSkyColor = { r: 0, g: 0, b: 0 }; const targetSkyColor = { r: 0, g: 0, b: 0 };
        function colorSky(speed) {
            const maxSkySaturation = (+store.state.config.skyLighting) * 15; const maxStarCount = 500; let totalStarCount = 0;
            targetSkyColor.r = 0; targetSkyColor.g = 0; targetSkyColor.b = 0;
            COLOR_CODES.forEach(color => { const tuple = COLOR_TUPLES[color]; const count = Star.active[color].length; totalStarCount += count; targetSkyColor.r += tuple.r * count; targetSkyColor.g += tuple.g * count; targetSkyColor.b += tuple.b * count; });
            const intensity = Math.pow(Math.min(1, totalStarCount / maxStarCount), 0.3); const maxColorComponent = Math.max(1, targetSkyColor.r, targetSkyColor.g, targetSkyColor.b);
            targetSkyColor.r = (targetSkyColor.r / maxColorComponent) * maxSkySaturation * intensity; targetSkyColor.g = (targetSkyColor.g / maxColorComponent) * maxSkySaturation * intensity; targetSkyColor.b = (targetSkyColor.b / maxColorComponent) * maxSkySaturation * intensity;
            const colorChange = 10;
            currentSkyColor.r += ((targetSkyColor.r - currentSkyColor.r) / colorChange) * speed; currentSkyColor.g += ((targetSkyColor.g - currentSkyColor.g) / colorChange) * speed; currentSkyColor.b += ((targetSkyColor.b - currentSkyColor.b) / colorChange) * speed;
            document.querySelector('.canvas-container').style.backgroundColor = `rgb(${currentSkyColor.r | 0}, ${currentSkyColor.g | 0}, ${currentSkyColor.b | 0})`;
        }
        mainStage.addEventListener("ticker", update);

        // Particle Factories
        function createParticleArc(start, arcLength, count, randomness, particleFactory) { const angleDelta = arcLength / count; const end = start + arcLength - angleDelta * 0.5; if (end > start) { for (let angle = start; angle < end; angle = angle + angleDelta) { particleFactory(angle + Math.random() * angleDelta * randomness); } } else { for (let angle = start; angle > end; angle = angle + angleDelta) { particleFactory(angle + Math.random() * angleDelta * randomness); } } }
        function createBurst(count, particleFactory, startAngle = 0, arcLength = PI_2) { const R = 0.5 * Math.sqrt(count / Math.PI); const C = 2 * R * Math.PI; const C_HALF = C / 2; for (let i = 0; i <= C_HALF; i++) { const ringAngle = (i / C_HALF) * PI_HALF; const ringSize = Math.cos(ringAngle); const partsPerFullRing = C * ringSize; const partsPerArc = partsPerFullRing * (arcLength / PI_2); const angleInc = PI_2 / partsPerFullRing; const angleOffset = Math.random() * angleInc + startAngle; const maxRandomAngleOffset = angleInc * 0.33; for (let i = 0; i < partsPerArc; i++) { const randomAngleOffset = Math.random() * maxRandomAngleOffset; let angle = angleInc * i + angleOffset + randomAngleOffset; particleFactory(angle, ringSize); } } }
        
        // Effects
        function crossetteEffect(star) { const startAngle = Math.random() * PI_HALF; createParticleArc(startAngle, PI_2, 4, 0.5, (angle) => { Star.add(star.x, star.y, star.color, angle, Math.random() * 0.6 + 0.75, 600); }); }
        function floralEffect(star) { const count = 12 + 6 * quality; createBurst(count, (angle, speedMult) => { Star.add(star.x, star.y, star.color, angle, speedMult * 2.4, 1000 + Math.random() * 300, star.speedX, star.speedY); }); BurstFlash.add(star.x, star.y, 46); soundManager.playSound("burstSmall"); }
        function fallingLeavesEffect(star) { createBurst(7, (angle, speedMult) => { const newStar = Star.add(star.x, star.y, INVISIBLE, angle, speedMult * 2.4, 2400 + Math.random() * 600, star.speedX, star.speedY); newStar.sparkColor = COLOR.Gold; newStar.sparkFreq = 144 / quality; newStar.sparkSpeed = 0.28; newStar.sparkLife = 750; newStar.sparkLifeVariation = 3.2; }); BurstFlash.add(star.x, star.y, 46); soundManager.playSound("burstSmall"); }
        function crackleEffect(star) { const count = isHighQuality ? 32 : 16; createParticleArc(0, PI_2, count, 1.8, (angle) => { Spark.add(star.x, star.y, COLOR.Gold, angle, Math.pow(Math.random(), 0.45) * 2.4, 300 + Math.random() * 200); }); }

        class Shell {
            constructor(options) { Object.assign(this, options); this.starLifeVariation = options.starLifeVariation || 0.125; this.color = options.color || randomColor(); this.glitterColor = options.glitterColor || this.color; if (!this.starCount) { const density = options.starDensity || 1; const scaledSize = this.spreadSize / 54; this.starCount = Math.max(6, scaledSize * scaledSize * density); } }
            launch(position, launchHeight) {
                const width = stageW; const height = stageH; const hpad = 60; const vpad = 50; const minHeightPercent = 0.45; const minHeight = height - height * minHeightPercent;
                const launchX = position * (width - hpad * 2) + hpad; const launchY = height; const burstY = minHeight - launchHeight * (minHeight - vpad); const launchDistance = launchY - burstY; const launchVelocity = Math.pow(launchDistance * 0.04, 0.64);
                const comet = (this.comet = Star.add(launchX, launchY, typeof this.color === "string" && this.color !== "random" ? this.color : COLOR.White, Math.PI, launchVelocity * (this.horsetail ? 1.2 : 1), launchVelocity * (this.horsetail ? 100 : 400)));
                comet.heavy = true; comet.spinRadius = MyMath.random(0.32, 0.85); comet.sparkFreq = 32 / quality; if (isHighQuality) comet.sparkFreq = 8; comet.sparkLife = 320; comet.sparkLifeVariation = 3;
                if (this.glitter === "willow" || this.fallingLeaves) { comet.sparkFreq = 20 / quality; comet.sparkSpeed = 0.5; comet.sparkLife = 500; }
                if (this.color === INVISIBLE) comet.sparkColor = COLOR.Gold;
                if (Math.random() > 0.4 && !this.horsetail) { comet.secondColor = INVISIBLE; comet.transitionTime = Math.pow(Math.random(), 1.5) * 700 + 500; }
                comet.onDeath = (comet) => this.burst(comet.x, comet.y);
                soundManager.playSound("lift");
            }
            burst(x, y) {
                const speed = this.spreadSize / 96; let color, onDeath, sparkFreq, sparkSpeed, sparkLife; let sparkLifeVariation = 0.25; let playedDeathSound = false;
                if (this.crossette) onDeath = (star) => { if (!playedDeathSound) { soundManager.playSound("crackleSmall"); playedDeathSound = true; } crossetteEffect(star); };
                if (this.crackle) onDeath = (star) => { if (!playedDeathSound) { soundManager.playSound("crackle"); playedDeathSound = true; } crackleEffect(star); };
                if (this.floral) onDeath = floralEffect; if (this.fallingLeaves) onDeath = fallingLeavesEffect;
                if (this.glitter === "light") { sparkFreq = 400; sparkSpeed = 0.3; sparkLife = 300; sparkLifeVariation = 2; } else if (this.glitter === "medium") { sparkFreq = 200; sparkSpeed = 0.44; sparkLife = 700; sparkLifeVariation = 2; } else if (this.glitter === "heavy") { sparkFreq = 80; sparkSpeed = 0.8; sparkLife = 1400; sparkLifeVariation = 2; } else if (this.glitter === "thick") { sparkFreq = 16; sparkSpeed = isHighQuality ? 1.65 : 1.5; sparkLife = 1400; sparkLifeVariation = 3; } else if (this.glitter === "streamer") { sparkFreq = 32; sparkSpeed = 1.05; sparkLife = 620; sparkLifeVariation = 2; } else if (this.glitter === "willow") { sparkFreq = 120; sparkSpeed = 0.34; sparkLife = 1400; sparkLifeVariation = 3.8; }
                sparkFreq = sparkFreq / quality; let firstStar = true;
                const starFactory = (angle, speedMult) => {
                    const standardInitialSpeed = this.spreadSize / 1800; const star = Star.add(x, y, color || randomColor(), angle, speedMult * speed, this.starLife + Math.random() * this.starLife * this.starLifeVariation, this.horsetail ? this.comet && this.comet.speedX : 0, this.horsetail ? this.comet && this.comet.speedY : -standardInitialSpeed);
                    if (this.secondColor) { star.transitionTime = this.starLife * (Math.random() * 0.05 + 0.32); star.secondColor = this.secondColor; }
                    if (this.strobe) { star.transitionTime = this.starLife * (Math.random() * 0.08 + 0.46); star.strobe = true; star.strobeFreq = Math.random() * 20 + 40; if (this.strobeColor) star.secondColor = this.strobeColor; }
                    star.onDeath = onDeath; if (this.glitter) { star.sparkFreq = sparkFreq; star.sparkSpeed = sparkSpeed; star.sparkLife = sparkLife; star.sparkLifeVariation = sparkLifeVariation; star.sparkColor = this.glitterColor; star.sparkTimer = Math.random() * star.sparkFreq; }
                };
                if (typeof this.color === "string") { if (this.color === "random") color = null; else color = this.color; if (this.ring) { const ringStartAngle = Math.random() * Math.PI; const ringSquash = Math.pow(Math.random(), 2) * 0.85 + 0.15; createParticleArc(0, PI_2, this.starCount, 0, (angle) => { const initSpeedX = Math.sin(angle) * speed * ringSquash; const initSpeedY = Math.cos(angle) * speed; const newSpeed = MyMath.pointDist(0, 0, initSpeedX, initSpeedY); const newAngle = MyMath.pointAngle(0, 0, initSpeedX, initSpeedY) + ringStartAngle; const star = Star.add(x, y, color, newAngle, newSpeed, this.starLife + Math.random() * this.starLife * this.starLifeVariation); if (this.glitter) { star.sparkFreq = sparkFreq; star.sparkSpeed = sparkSpeed; star.sparkLife = sparkLife; star.sparkLifeVariation = sparkLifeVariation; star.sparkColor = this.glitterColor; star.sparkTimer = Math.random() * star.sparkFreq; } }); } else { createBurst(this.starCount, starFactory); } } else if (Array.isArray(this.color)) { if (Math.random() < 0.5) { const start = Math.random() * Math.PI; const start2 = start + Math.PI; const arc = Math.PI; color = this.color[0]; createBurst(this.starCount, starFactory, start, arc); color = this.color[1]; createBurst(this.starCount, starFactory, start2, arc); } else { color = this.color[0]; createBurst(this.starCount / 2, starFactory); color = this.color[1]; createBurst(this.starCount / 2, starFactory); } }
                if (this.pistil) { const innerShell = new Shell({ spreadSize: this.spreadSize * 0.5, starLife: this.starLife * 0.6, starLifeVariation: this.starLifeVariation, starDensity: 1.4, color: this.pistilColor, glitter: "light", glitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White, }); innerShell.burst(x, y); }
                if (this.streamers) { const innerShell = new Shell({ spreadSize: this.spreadSize * 0.9, starLife: this.starLife * 0.8, starLifeVariation: this.starLifeVariation, starCount: Math.floor(Math.max(6, this.spreadSize / 45)), color: COLOR.White, glitter: "streamer", }); innerShell.burst(x, y); }
                BurstFlash.add(x, y, this.spreadSize / 4);
                if (this.comet) { const maxDiff = 2; const sizeDifferenceFromMaxSize = Math.min(maxDiff, +store.state.config.size - this.shellSize); const soundScale = (1 - sizeDifferenceFromMaxSize / maxDiff) * 0.3 + 0.7; soundManager.playSound("burst", soundScale); }
            }
        }

        const BurstFlash = { active: [], _pool: [], _new() { return {}; }, add(x, y, radius) { const instance = this._pool.pop() || this._new(); instance.x = x; instance.y = y; instance.radius = radius; this.active.push(instance); return instance; }, returnInstance(instance) { this._pool.push(instance); }, };
        function createParticleCollection() { const collection = {}; COLOR_CODES_W_INVIS.forEach(color => { collection[color] = []; }); return collection; }
        const Star = { drawWidth: 3, airDrag: 0.98, airDragHeavy: 0.992, active: createParticleCollection(), _pool: [], _new() { return {}; }, add(x, y, color, angle, speed, life, speedOffX, speedOffY) { const instance = this._pool.pop() || this._new(); instance.visible = true; instance.heavy = false; instance.x = x; instance.y = y; instance.prevX = x; instance.prevY = y; instance.color = color; instance.speedX = Math.sin(angle) * speed + (speedOffX || 0); instance.speedY = Math.cos(angle) * speed + (speedOffY || 0); instance.life = life; instance.fullLife = life; instance.spinAngle = Math.random() * PI_2; instance.spinSpeed = 0.8; instance.spinRadius = 0; instance.sparkFreq = 0; instance.sparkSpeed = 1; instance.sparkTimer = 0; instance.sparkColor = color; instance.sparkLife = 750; instance.sparkLifeVariation = 0.25; instance.strobe = false; this.active[color].push(instance); return instance; }, returnInstance(instance) { instance.onDeath && instance.onDeath(instance); instance.onDeath = null; instance.secondColor = null; instance.transitionTime = 0; instance.colorChanged = false; this._pool.push(instance); }, };
        const Spark = { drawWidth: 0, airDrag: 0.9, active: createParticleCollection(), _pool: [], _new() { return {}; }, add(x, y, color, angle, speed, life) { const instance = this._pool.pop() || this._new(); instance.x = x; instance.y = y; instance.prevX = x; instance.prevY = y; instance.color = color; instance.speedX = Math.sin(angle) * speed; instance.speedY = Math.cos(angle) * speed; instance.life = life; this.active[color].push(instance); return instance; }, returnInstance(instance) { this._pool.push(instance); }, };
        
        const soundManager = {
            baseURL: "https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/", ctx: new (window.AudioContext || window.webkitAudioContext)(),
            sources: { lift: { volume: 1, playbackRateMin: 0.85, playbackRateMax: 0.95, fileNames: ["lift1.mp3", "lift2.mp3", "lift3.mp3"], }, burst: { volume: 1, playbackRateMin: 0.8, playbackRateMax: 0.9, fileNames: ["burst1.mp3", "burst2.mp3"], }, burstSmall: { volume: 0.25, playbackRateMin: 0.8, playbackRateMax: 1, fileNames: ["burst-sm-1.mp3", "burst-sm-2.mp3"], }, crackle: { volume: 0.2, playbackRateMin: 1, playbackRateMax: 1, fileNames: ["crackle1.mp3"], }, crackleSmall: { volume: 0.3, playbackRateMin: 1, playbackRateMax: 1, fileNames: ["crackle-sm-1.mp3"], }, },
            preload() { const allFilePromises = []; function checkStatus(response) { if (response.status >= 200 && response.status < 300) { return response; } const customError = new Error(response.statusText); customError.response = response; throw customError; } const types = Object.keys(this.sources); types.forEach((type) => { const source = this.sources[type]; const { fileNames } = source; const filePromises = []; fileNames.forEach((fileName) => { const fileURL = this.baseURL + fileName; const promise = fetch(fileURL) .then(checkStatus) .then((response) => response.arrayBuffer()) .then( (data) => new Promise((resolve) => { this.ctx.decodeAudioData(data, resolve); }) ); filePromises.push(promise); allFilePromises.push(promise); }); Promise.all(filePromises).then((buffers) => { source.buffers = buffers; }); }); return Promise.all(allFilePromises); },
            pauseAll() { this.ctx.suspend(); }, resumeAll() { this.playSound("lift", 0); setTimeout(() => { this.ctx.resume(); }, 250); }, _lastSmallBurstTime: 0,
            playSound(type, scale = 1) { scale = MyMath.clamp(scale, 0, 1); if (!store.state.soundEnabled || simSpeed < 0.95) return; if (type === "burstSmall") { const now = Date.now(); if (now - this._lastSmallBurstTime < 20) return; this._lastSmallBurstTime = now; } const source = this.sources[type]; if (!source) throw new Error(`Sound of type "${type}" doesn't exist.`); const initialVolume = source.volume; const initialPlaybackRate = MyMath.random( source.playbackRateMin, source.playbackRateMax ); const scaledVolume = initialVolume * scale; const scaledPlaybackRate = initialPlaybackRate * (2 - scale); const gainNode = this.ctx.createGain(); gainNode.gain.value = scaledVolume; const buffer = MyMath.randomChoice(source.buffers); const bufferSource = this.ctx.createBufferSource(); bufferSource.playbackRate.value = scaledPlaybackRate; bufferSource.buffer = buffer; bufferSource.connect(gainNode); gainNode.connect(this.ctx.destination); bufferSource.start(0); },
        };

        function handleResize() {
            const w = window.innerWidth; const h = window.innerHeight;
            const containerW = Math.min(w, MAX_WIDTH); const containerH = w <= 420 ? h : Math.min(h, MAX_HEIGHT);
            stages.forEach(stage => stage.resize(containerW, containerH));
            const scaleFactor = +store.state.config.scaleFactor;
            stageW = containerW / scaleFactor; stageH = containerH / scaleFactor;
        }
        window.addEventListener("resize", handleResize);

        // --- K√çCH HO·∫†T PH√ÅO HOA ---
        function startFireworksShow() {
            handleResize();
            if (soundManager && soundManager.preload) {
                soundManager.preload().then(() => {}, (e) => {});
            }
            
            store.setState({ 
                paused: false,
                config: {
                    ...store.state.config,
                    autoLaunch: true 
                }
            });

            // Kh√¥ng c√≤n d√πng showState = 'IDLE' cho drone n·ªØa
        }

        // --- INTERACTION (L√å X√å & TH∆Ø) ---
        const btnLixi = document.getElementById('lixi-btn');
        const overlay = document.getElementById('lixi-overlay');
        const envContainer = document.getElementById('env-container');
        const letterModal = document.getElementById('letter-modal');
        const letterContent = document.getElementById('letter-content');
        let openedCount = 0;
        let currentEnvelopeEl = null;

        btnLixi.addEventListener('click', () => {
            btnLixi.style.display = 'none'; 
            overlay.style.display = 'flex'; overlay.style.background = 'rgba(0,0,0,0.4)'; overlay.style.backdropFilter = 'blur(0px)';
            envContainer.innerHTML = '';
            for(let i=1; i <= LETTERS.length; i++) {
                const envWrapper = document.createElement('div');
                envWrapper.className = 'envelope-wrapper';
                envWrapper.style.animation = `flyIn 1s ease forwards ${i*0.15}s`;
                envWrapper.innerHTML = `<div class="env-flap"></div><div class="env-paper">‚úâÔ∏è Surprise!</div><div class="env-body"><div class="coin-deco">Ph√∫c</div></div>`;
                envWrapper.onclick = () => openEnvelope(i-1, envWrapper);
                envContainer.appendChild(envWrapper);
            }
        });

        function openEnvelope(index, el) {
            currentEnvelopeEl = el; el.classList.add('active'); 
            overlay.style.backdropFilter = "blur(8px)"; overlay.style.background = "rgba(0,0,0,0.6)";
            setTimeout(() => {
                letterContent.innerHTML = LETTERS[index];
                letterModal.classList.add('show-flip'); el.style.opacity = '0'; 
            }, 900); 
            openedCount++;
        }

        function closeLetter() {
            letterModal.classList.remove('show-flip');
            overlay.style.backdropFilter = "blur(0px)"; overlay.style.background = "rgba(0,0,0,0.4)";
            if(currentEnvelopeEl) currentEnvelopeEl.style.display = 'none'; 
            if (openedCount === LETTERS.length) setTimeout(showFinalScene, 1000);
        }

        function showFinalScene() {
            overlay.style.display = 'none'; btnLixi.style.display = 'none';
            
            store.setState({ paused: true });
            document.querySelector('.canvas-container').style.display = 'none';

            document.body.style.background = "radial-gradient(circle, #5e0000, #1a0000)";
            document.getElementById('final-screen').style.display = 'flex';
            
            const finalTextContainer = document.querySelector('.final-text');
            let htmlContent = finalTextContainer.innerHTML; let parts = htmlContent.split('<br>'); let textToWave = parts[0]; 
            let wavedText = textToWave.split('').map((char, index) => {
                if (char === ' ') return ' '; 
                return `<span class="wavy-char" style="animation-delay: ${index * 0.1}s">${char}</span>`;
            }).join('');
            finalTextContainer.innerHTML = wavedText + '<br>' + parts[1];

            setTimeout(() => {
                document.getElementById('love-message').classList.add('show-love');
                spawnLoveConfetti();
            }, 2500);
            
            setTimeout(() => { document.getElementById('redirect-btn').classList.add('show-btn'); }, 5000);

            const icons = ['üå∏', '‚ú®', 'üçÄ', '‚ù§Ô∏è', 'ü•∞', 'ü¶ã', 'üéÅ', 'üíñ', 'üåü'];
            const fs = document.getElementById('final-screen');
            setInterval(() => {
                const ic = document.createElement('div'); ic.className = 'final-icon';
                ic.innerText = icons[Math.floor(Math.random()*icons.length)];
                ic.style.left = Math.random()*100 + '%'; ic.style.top = (Math.random()*40 + 60) + '%'; 
                ic.style.animationDuration = (Math.random()*3 + 3) + 's';
                fs.appendChild(ic); setTimeout(() => ic.remove(), 6000);
            }, 200);
        }
        
        function spawnLoveConfetti() {
            for(let i=0; i<20; i++){
                setTimeout(() => {
                    const ic = document.createElement('div'); ic.className = 'final-icon'; ic.innerText = '‚ù§Ô∏è';
                    ic.style.left = (40 + Math.random()*20) + '%'; ic.style.top = '60%'; 
                    ic.style.animationDuration = (2 + Math.random()) + 's';
                    document.getElementById('final-screen').appendChild(ic);
                }, i * 100);
            }
        }

        // --- X·ª¨ L√ù CHUY·ªÇN TRANG CU·ªêI C√ôNG (S·ªî TAY) ---
        function goToNextPage() {
            document.getElementById('final-screen').style.display = 'none';
            const customPage = document.getElementById('my-custom-page');
            
            // Hi·ªán block
            customPage.style.display = 'block';

            // Xo√° transition c≈© ƒë·ªÉ tr√°nh xung ƒë·ªôt opacity
            // v√† hi·ªán trang ngay l·∫≠p t·ª©c
            customPage.style.opacity = '1';
            
            // ƒê·ª£i 1 ch√∫t ƒë·ªÉ DOM c·∫≠p nh·∫≠t r·ªìi m·ªõi v·∫Ω
            setTimeout(initCustomCanvas, 50);
        }

        function initCustomCanvas() {
            const canvas = document.getElementById('final-custom-canvas');
            const ctx = canvas.getContext('2d');
            let w, h;

            function resize() {
                // L·∫•y k√≠ch th∆∞·ªõc th·∫≠t c·ªßa c·ª≠a s·ªï
                w = canvas.width = window.innerWidth;
                h = canvas.height = window.innerHeight;
            }
            // G·ªçi resize ngay ƒë·ªÉ l·∫•y k√≠ch th∆∞·ªõc
            resize(); 
            window.addEventListener('resize', resize);

            // C·∫•u h√¨nh v·∫Ω
            const lineHeight = 40; 
            const marginTop = 60;
            const holeX = 40;     // V·ªã tr√≠ x c·ªßa l·ªó ƒë·ª•c
            const holeW = 15;     // Chi·ªÅu r·ªông l·ªó
            const holeH = 20;     // Chi·ªÅu cao l·ªó
            const lineStartX = 80;// D√≤ng k·∫ª b·∫Øt ƒë·∫ßu t·ª´ ƒë√¢u
            
            // M√†u s·∫Øc
            const paperColor = '#f8f8f8'; // M√†u gi·∫•y (tr√πng background css)
            const holeColor = '#333';     // M√†u l·ªó ƒë·ª•c
            const lineColor = '#000';     // M√†u d√≤ng k·∫ª ƒêEN

            let currentLine = 0;
            let maxLines = 0;

            function drawFrame() {
                // T√≠nh s·ªë d√≤ng t·ªëi ƒëa d·ª±a tr√™n chi·ªÅu cao m√†n h√¨nh
                maxLines = Math.floor((h - marginTop) / lineHeight);

                // 1. X√≥a to√†n b·ªô canvas v√† v·∫Ω n·ªÅn tr·∫Øng
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = paperColor;
                ctx.fillRect(0, 0, w, h);

                // 2. V·∫Ω h√†ng l·ªó l√≤ xo b√™n tr√°i (lu√¥n v·∫Ω h·∫øt)
                ctx.fillStyle = holeColor;
                for (let y = marginTop - 10; y < h; y += lineHeight) {
                    // V·∫Ω l·ªó ƒë·ª•c h√¨nh ch·ªØ nh·∫≠t bo g√≥c nh·∫π
                    ctx.beginPath();
                    ctx.roundRect(holeX, y, holeW, holeH, 2);
                    ctx.fill();
                }

                // 3. V·∫Ω c√°c d√≤ng k·∫ª ngang (xu·∫•t hi·ªán d·∫ßn d·∫ßn)
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1.5;
                ctx.beginPath();

                for (let i = 0; i < currentLine; i++) {
                    const y = marginTop + i * lineHeight + (holeH/2); 
                    // V·∫Ω ƒë∆∞·ªùng k·∫ª
                    ctx.moveTo(lineStartX, y);
                    ctx.lineTo(w - 20, y);
                }
                ctx.stroke();

                // 4. V·∫Ω ti√™u ƒë·ªÅ (ch·ªâ hi·ªán khi ƒë√£ v·∫Ω ƒë∆∞·ª£c v√†i d√≤ng)
                if (currentLine > 2) {
                    ctx.font = "bold 30px 'Patrick Hand', cursive"; // Font ch·ªØ tay
                    ctx.fillStyle = "#333";
                    ctx.fillText("Nh·∫≠t k√Ω 2026...", lineStartX, marginTop - 15);
                }

                // TƒÉng bi·∫øn ƒë·∫øm ƒë·ªÉ t·∫°o animation
                if (currentLine < maxLines + 5) {
                    currentLine += 0.25; // T·ªëc ƒë·ªô xu·∫•t hi·ªán
                    requestAnimationFrame(drawFrame);
                }
            }

            // B·∫Øt ƒë·∫ßu v·∫Ω
            drawFrame();
        }

    </script>
</body>
</html>